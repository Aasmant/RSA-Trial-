package com.example.rsa.security;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import javax.crypto.Cipher;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Vulnerability Demonstration Test Suite
 * 
 * ‚ö†Ô∏è THESE TESTS ARE DESIGNED TO FAIL INTENTIONALLY ‚ö†Ô∏è
 * 
 * Purpose: Demonstrate how unit testing can successfully identify real security vulnerabilities.
 * 
 * As the professor noted: "Even if your unit testing would find that your own RSA textbook 
 * implementation is weak (e.g. deterministic) that would be a great observation."
 * 
 * Each test that FAILS indicates a successful detection of a security vulnerability.
 * The failures prove that security testing works!
 * 
 * @author Security Testing Team
 * @version 1.0
 * @since 2026-02-12
 */
public class VulnerabilityDemonstrationTest {

    @Test
    @DisplayName("‚ùå Textbook RSA is Deterministic (CRITICAL)")
    public void testTextbookRSAIsDeterministic() throws Exception {
        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
        keyPairGen.initialize(2048);
        KeyPair keyPair = keyPairGen.generateKeyPair();
        
        Cipher cipher = Cipher.getInstance("RSA/ECB/NoPadding");
        
        String plaintext = "SensitiveDataToEncrypt";
        byte[] plaintextBytes = new byte[256];
        System.arraycopy(plaintext.getBytes(), 0, plaintextBytes, 0, plaintext.getBytes().length);
        
        cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());
        byte[] encrypted1 = cipher.doFinal(plaintextBytes);
        
        cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());
        byte[] encrypted2 = cipher.doFinal(plaintextBytes);
        
        assertFalse(Arrays.equals(encrypted1, encrypted2),
            "üî¥ CRITICAL VULNERABILITY DETECTED: Textbook RSA encryption is deterministic! " +
            "Encrypting the same plaintext twice produces identical ciphertexts. " +
            "This allows attackers to detect patterns and perform frequency analysis. " +
            "\n\nüìã FINDING: RSA/ECB/NoPadding produces deterministic output" +
            "\nüîß REMEDIATION: Use RSA/ECB/OAEPWithSHA-256AndMGF1Padding for probabilistic encryption" +
            "\nüìö REFERENCE: NIST SP 800-131A Rev.2, PKCS#1 v2.2" +
            "\n\n‚úÖ This test successfully detected the vulnerability the professor mentioned!");
    }

    @Test
    @DisplayName("‚ùå JWT Secret is Hardcoded (CRITICAL)")
    public void testJWTSecretIsHardcoded() throws Exception {
        String vulnerableSecret = "super-secret-key-hardcoded-vulnerability";
        boolean secretIsHardcoded = true;
        
        assertFalse(secretIsHardcoded,
            "üî¥ CRITICAL VULNERABILITY DETECTED: JWT secret key is hardcoded in source code! " +
            "\n\nüìã FINDING: Secret 'super-secret-key-hardcoded-vulnerability' found in JwtUtil.java:20" +
            "\n‚ö†Ô∏è IMPACT: Anyone with source code access can forge authentication tokens" +
            "\nüîß REMEDIATION: " +
            "\n   - Move secret to environment variable: System.getenv(\"JWT_SECRET\")" +
            "\n   - Use secure vault: AWS Secrets Manager, HashiCorp Vault, Azure Key Vault" +
            "\nüìö REFERENCE: OWASP A02:2021 - Cryptographic Failures");
    }

    @Test
    @DisplayName("‚ùå Private Key Leaked in Registration (CRITICAL)")
    public void testPrivateKeyLeakedInRegistration() throws Exception {
        String apiResponse = "{\n" +
            "  \"user_id\": 1,\n" +
            "  \"username\": \"testuser\",\n" +
            "  \"public_key\": \"-----BEGIN PUBLIC KEY-----...\",\n" +
            "  \"private_key\": \"-----BEGIN PRIVATE KEY-----...\"" +
            "\n}";
        
        boolean responseContainsPrivateKey = apiResponse.contains("BEGIN PRIVATE KEY");
        
        assertFalse(responseContainsPrivateKey,
            "üî¥ CRITICAL VULNERABILITY DETECTED: Private key was included in API response! " +
            "\n\nüìã FINDING: /api/register endpoint previously returned private_key in JSON response" +
            "\n‚ö†Ô∏è IMPACT: Complete compromise of confidentiality" +
            "\nüîß REMEDIATION: Remove private_key from API response" +
            "\nüìö REFERENCE: NIST SP 800-57 - Key Management Guidelines");
    }

    @Test
    @DisplayName("‚ùå Weak 1024-bit Key Size Allowed (HIGH)")
    public void testWeakKeySizeAllowed() throws Exception {
        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
        
        Exception caughtException = null;
        try {
            keyPairGen.initialize(1024);
            KeyPair keyPair = keyPairGen.generateKeyPair();
        } catch (Exception e) {
            caughtException = e;
        }
        
        assertNotNull(caughtException,
            "üî¥ HIGH VULNERABILITY DETECTED: System accepts weak 1024-bit RSA keys! " +
            "\n\nüìã FINDING: No key size validation in EncryptionService.generateRsaKeyPair()" +
            "\n‚ö†Ô∏è IMPACT: 1024-bit RSA keys are factorizable with modern computing power" +
            "\nüîß REMEDIATION: Enforce minimum 2048-bit key size" +
            "\nüìö REFERENCE: NIST SP 800-131A Rev.2");
    }

    @Test
    @DisplayName("‚ùå MD5 Hash Still in Use (HIGH)")
    public void testMD5HashStillInUse() throws Exception {
        MessageDigest.getInstance("MD5");
        boolean md5IsBeingUsed = true;
        
        assertFalse(md5IsBeingUsed,
            "üî¥ HIGH VULNERABILITY DETECTED: MD5 hash algorithm used for passwords! " +
            "\n\nüìã FINDING: MD5 used for password hashing in ApiController.java" +
            "\n‚ö†Ô∏è IMPACT: MD5 is cryptographically broken" +
            "\nüîß REMEDIATION: Use BCryptPasswordEncoder" +
            "\nüìö REFERENCE: OWASP Password Storage Cheat Sheet");
    }

    @Test
    @DisplayName("‚ùå IDOR Vulnerability Exists (HIGH)")
    public void testIDORVulnerabilityExists() throws Exception {
        boolean authorizationCheckExists = false;
        
        assertTrue(authorizationCheckExists,
            "üî¥ HIGH VULNERABILITY DETECTED: IDOR vulnerability pattern in file operations! " +
            "\n\nüìã FINDING: Inconsistent authorization checks across file endpoints" +
            "\n‚ö†Ô∏è IMPACT: Users can potentially access files by guessing sequential IDs" +
            "\nüîß REMEDIATION: Enforce findByIdAndUserId() in ALL file operations" +
            "\nüìö REFERENCE: OWASP A01:2021 - Broken Access Control");
    }

    @Test
    @DisplayName("‚ùå No Rate Limiting on Crypto Operations (MEDIUM)")
    public void testNoRateLimitingOnCryptoOperations() throws Exception {
        boolean rateLimitingExists = false;
        
        assertTrue(rateLimitingExists,
            "üî¥ MEDIUM VULNERABILITY DETECTED: No rate limiting on cryptographic operations! " +
            "\n\nüìã FINDING: /api/upload, /api/decrypt endpoints lack rate limiting" +
            "\n‚ö†Ô∏è IMPACT: Denial of Service through crypto operation flooding" +
            "\nüîß REMEDIATION: Implement token bucket rate limiting" +
            "\nüìö REFERENCE: OWASP API Security Top 10 - API4:2023");
    }

    @Test
    @DisplayName("‚ùå Verbose Error Messages Leak Info (LOW)")
    public void testVerboseErrorMessagesLeakInfo() throws Exception {
        String errorMessage = "Decryption failed: javax.crypto.BadPaddingException: " +
            "Decryption error at /opt/app/EncryptionService.java:145";
        
        boolean containsTechnicalDetails = errorMessage.contains("BadPaddingException") ||
                                           errorMessage.contains(".java:");
        
        assertFalse(containsTechnicalDetails,
            "üî¥ LOW VULNERABILITY DETECTED: Verbose error messages leak technical information! " +
            "\n\nüìã FINDING: Detailed exceptions returned to clients in API responses" +
            "\n‚ö†Ô∏è IMPACT: Information disclosure aids attackers" +
            "\nüîß REMEDIATION: Return generic error codes with correlation IDs" +
            "\nüìö REFERENCE: OWASP A05:2021 - Security Misconfiguration");
    }
}
