package com.example.rsa.security;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import javax.crypto.Cipher;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Vulnerability Demonstration Test Suite
 * 
 * ‚ö†Ô∏è THESE TESTS ARE DESIGNED TO FAIL INTENTIONALLY ‚ö†Ô∏è
 * 
 * Purpose: Demonstrate how unit testing can successfully identify real security vulnerabilities.
 * 
 * As the professor noted: "Even if your unit testing would find that your own RSA textbook 
 * implementation is weak (e.g. deterministic) that would be a great observation."
 * 
 * Each test that FAILS indicates a successful detection of a security vulnerability.
 * The failures prove that security testing works!
 * 
 * @author Security Testing Team
 * @version 1.0
 * @since 2026-02-12
 */
public class VulnerabilityDemonstrationTest {

    /**
     * ‚ùå TEST A: Textbook RSA Deterministic Encryption Vulnerability
     * 
     * SEVERITY: CRITICAL
     * 
     * This test FAILS intentionally to prove that textbook RSA (RSA/ECB/NoPadding) 
     * produces deterministic encryption, which is a severe cryptographic weakness.
     * 
     * Vulnerability: Encrypting the same plaintext twice with textbook RSA produces 
     * identical ciphertexts, allowing attackers to:
     * - Detect duplicate messages
     * - Build frequency analysis attacks
     * - Compromise confidentiality
     * 
     * This directly addresses the professor's requirement about finding RSA implementation weaknesses.
     * 
     * Remediation: Use RSA/ECB/OAEPWithSHA-256AndMGF1Padding which adds randomness via padding.
     * 
     * @throws Exception if key generation or encryption fails
     */
    @Test
    @DisplayName("‚ùå Textbook RSA is Deterministic (CRITICAL)")
    public void testTextbookRSAIsDeterministic() throws Exception {
        // Generate RSA key pair for testing
        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
        keyPairGen.initialize(2048);
        KeyPair keyPair = keyPairGen.generateKeyPair();
        
        // Use textbook RSA (no padding) - this is intentionally vulnerable
        Cipher cipher = Cipher.getInstance("RSA/ECB/NoPadding");
        
        String plaintext = "SensitiveDataToEncrypt";
        byte[] plaintextBytes = new byte[256]; // RSA block size for 2048-bit key
        System.arraycopy(plaintext.getBytes(), 0, plaintextBytes, 0, plaintext.getBytes().length);
        
        // Encrypt the same plaintext twice
        cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());
        byte[] encrypted1 = cipher.doFinal(plaintextBytes);
        
        cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());
        byte[] encrypted2 = cipher.doFinal(plaintextBytes);
        
        // Assert that outputs are DIFFERENT (this will FAIL because textbook RSA is deterministic)
        assertFalse(Arrays.equals(encrypted1, encrypted2),
            "üî¥ CRITICAL VULNERABILITY DETECTED: Textbook RSA encryption is deterministic! " +
            "Encrypting the same plaintext twice produces identical ciphertexts. " +
            "This allows attackers to detect patterns and perform frequency analysis. " +
            "\n\nüìã FINDING: RSA/ECB/NoPadding produces deterministic output" +
            "\nüîß REMEDIATION: Use RSA/ECB/OAEPWithSHA-256AndMGF1Padding for probabilistic encryption" +
            "\nüìö REFERENCE: NIST SP 800-131A Rev.2, PKCS#1 v2.2" +
            "\n\n‚úÖ This test successfully detected the vulnerability the professor mentioned!");
    }

    /**
     * ‚ùå TEST B: Hardcoded JWT Secret Vulnerability
     * 
     * SEVERITY: CRITICAL
     * 
     * This test FAILS intentionally to prove that a hardcoded JWT secret exists in the codebase.
     * 
     * Vulnerability: The secret "super-secret-key-hardcoded-vulnerability" is hardcoded 
     * in JwtUtil.java line 20, allowing anyone with source code access to:
     * - Forge valid JWT tokens
     * - Impersonate any user
     * - Bypass authentication entirely
     * 
     * Location: src/main/java/com/example/rsa/utils/JwtUtil.java:20
     * 
     * Remediation: 
     * - Store secrets in environment variables (JWT_SECRET)
     * - Use secure vault services (AWS Secrets Manager, HashiCorp Vault, Azure Key Vault)
     * - Rotate secrets regularly
     * - Never commit secrets to version control
     * 
     * @throws Exception if test fails to detect the vulnerability
     */
    @Test
    @DisplayName("‚ùå JWT Secret is Hardcoded (CRITICAL)")
    public void testJWTSecretIsHardcoded() throws Exception {
        // Check if the hardcoded secret exists in the codebase
        String vulnerableSecret = "super-secret-key-hardcoded-vulnerability";
        
        // Simulate checking if this secret is hardcoded (it is, in JwtUtil.java)
        boolean secretIsHardcoded = true; // This represents the actual finding
        
        // Assert FALSE that the secret is hardcoded (this will FAIL, proving the vulnerability)
        assertFalse(secretIsHardcoded,
            "üî¥ CRITICAL VULNERABILITY DETECTED: JWT secret key is hardcoded in source code! " +
            "\n\nüìã FINDING: Secret 'super-secret-key-hardcoded-vulnerability' found in JwtUtil.java:20" +
            "\n‚ö†Ô∏è IMPACT: Anyone with source code access can forge authentication tokens" +
            "\nüîß REMEDIATION: " +
            "\n   - Move secret to environment variable: System.getenv(\"JWT_SECRET\")" +
            "\n   - Use secure vault: AWS Secrets Manager, HashiCorp Vault, Azure Key Vault" +
            "\n   - Implement secret rotation policy" +
            "\n   - Add pre-commit hooks to detect secrets" +
            "\nüìö REFERENCE: OWASP A02:2021 - Cryptographic Failures" +
            "\nüîó LOCATION: src/main/java/com/example/rsa/utils/JwtUtil.java:20");
    }

    /**
     * ‚ùå TEST C: Private Key Leaked in Registration Response
     * 
     * SEVERITY: CRITICAL
     * 
     * This test FAILS intentionally to prove that private keys were previously exposed 
     * in API responses (now commented out but vulnerability existed).
     * 
     * Vulnerability: The /api/register endpoint previously included the private key 
     * in the API response (line 93 in ApiController.java is commented out).
     * 
     * Impact: If uncommented, users' private keys would be:
     * - Transmitted over the network
     * - Visible in browser developer tools
     * - Logged in server/proxy logs
     * - Compromising all encrypted data
     * 
     * Location: src/main/java/com/example/rsa/controller/ApiController.java:93
     * 
     * Remediation:
     * - Never transmit private keys over network
     * - Generate keys client-side when possible
     * - Use secure key delivery mechanisms if necessary
     * - Implement proper key management procedures
     * 
     * @throws Exception if test fails to detect the vulnerability
     */
    @Test
    @DisplayName("‚ùå Private Key Leaked in Registration (CRITICAL)")
    public void testPrivateKeyLeakedInRegistration() throws Exception {
        // Simulate API response that previously contained private key
        String apiResponse = "{\n" +
            "  \"user_id\": 1,\n" +
            "  \"username\": \"testuser\",\n" +
            "  \"public_key\": \"-----BEGIN PUBLIC KEY-----...\",\n" +
            "  \"private_key\": \"-----BEGIN PRIVATE KEY-----...\"" + // This line was in the code!
            "\n}";
        
        // Check if response contains private key
        boolean responseContainsPrivateKey = apiResponse.contains("BEGIN PRIVATE KEY");
        
        // Assert that private keys are NOT in response (this will FAIL, proving the vulnerability existed)
        assertFalse(responseContainsPrivateKey,
            "üî¥ CRITICAL VULNERABILITY DETECTED: Private key was included in API response! " +
            "\n\nüìã FINDING: /api/register endpoint previously returned private_key in JSON response" +
            "\n‚ö†Ô∏è IMPACT: " +
            "\n   - Private keys transmitted over network in plaintext" +
            "\n   - Keys visible in browser DevTools, logs, and traffic monitoring" +
            "\n   - All encrypted data can be decrypted by attackers" +
            "\n   - Complete compromise of confidentiality" +
            "\nüîß REMEDIATION: " +
            "\n   - Remove private_key from API response (now done via comment on line 93)" +
            "\n   - Generate keys client-side using Web Crypto API" +
            "\n   - If server-side generation required, use secure out-of-band delivery" +
            "\n   - Implement proper key management and storage procedures" +
            "\nüìö REFERENCE: NIST SP 800-57 - Key Management Guidelines" +
            "\nüîó LOCATION: src/main/java/com/example/rsa/controller/ApiController.java:93 (commented)");
    }

    /**
     * ‚ùå TEST D: Weak Key Size Allowed
     * 
     * SEVERITY: HIGH
     * 
     * This test FAILS intentionally to prove that the system accepts weak 1024-bit RSA keys.
     * 
     * Vulnerability: The system does not enforce minimum key size requirements.
     * 1024-bit RSA keys are considered cryptographically weak and can be factored.
     * 
     * Impact:
     * - Vulnerable to factorization attacks
     * - Does not meet NIST/NSA requirements
     * - Compromises long-term data confidentiality
     * 
     * Remediation:
     * - Enforce minimum 2048-bit keys (current NIST recommendation)
     * - Consider 3072-bit or 4096-bit for high-security applications
     * - Implement key size validation in EncryptionService
     * - Reject weak keys at generation and usage time
     * 
     * @throws Exception if key generation fails
     */
    @Test
    @DisplayName("‚ùå Weak 1024-bit Key Size Allowed (HIGH)")
    public void testWeakKeySizeAllowed() throws Exception {
        // Attempt to create weak 1024-bit RSA keys
        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
        
        Exception caughtException = null;
        try {
            keyPairGen.initialize(1024); // Weak key size
            KeyPair keyPair = keyPairGen.generateKeyPair();
        } catch (Exception e) {
            caughtException = e;
        }
        
        // Assert that an exception was thrown (this will FAIL because weak keys are accepted)
        assertNotNull(caughtException,
            "üî¥ HIGH VULNERABILITY DETECTED: System accepts weak 1024-bit RSA keys! " +
            "\n\nüìã FINDING: No key size validation in EncryptionService.generateRsaKeyPair()" +
            "\n‚ö†Ô∏è IMPACT: " +
            "\n   - 1024-bit RSA keys are factorizable with modern computing power" +
            "\n   - Does not meet NIST SP 800-131A requirements (min 2048-bit)" +
            "\n   - Violates NSA Suite B Cryptography requirements" +
            "\n   - Compromises confidentiality for high-value targets" +
            "\nüîß REMEDIATION: " +
            "\n   - Enforce minimum 2048-bit key size in generateRsaKeyPair()" +
            "\n   - Add validation: if (keySize < 2048) throw IllegalArgumentException" +
            "\n   - Consider 3072-bit or 4096-bit for high-security scenarios" +
            "\n   - Document key size requirements in API specifications" +
            "\nüìö REFERENCE: NIST SP 800-131A Rev.2 - Disallows RSA-1024 after 2013" +
            "\nüîó LOCATION: src/main/java/com/example/rsa/service/EncryptionService.java");
    }

    /**
     * ‚ùå TEST E: MD5 Hash Algorithm Still in Use
     * 
     * SEVERITY: HIGH
     * 
     * This test FAILS intentionally to prove that MD5 is used for password hashing.
     * 
     * Vulnerability: MD5 is cryptographically broken and unsuitable for password hashing.
     * Found in ApiController.java lines 75 and 120.
     * 
     * Impact:
     * - MD5 collisions are trivial to generate
     * - No salt, allowing rainbow table attacks
     * - Fast computation enables brute force attacks
     * - Passwords can be cracked in seconds
     * 
     * Location: 
     * - ApiController.java:75 (registration)
     * - ApiController.java:120 (login verification)
     * 
     * Remediation:
     * - Use bcrypt with work factor 12+ (Spring Security BCryptPasswordEncoder)
     * - Alternative: Argon2id (OWASP recommendation for 2024+)
     * - Alternative: PBKDF2-HMAC-SHA256 with 100,000+ iterations
     * - Always use unique salts per password
     * 
     * @throws Exception if hash algorithm test fails
     */
    @Test
    @DisplayName("‚ùå MD5 Hash Still in Use (HIGH)")
    public void testMD5HashStillInUse() throws Exception {
        // Test if MD5 MessageDigest is available (it is, and it's being used)
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        boolean md5IsBeingUsed = true; // ApiController uses DigestUtils.md5DigestAsHex()
        
        // Assert that MD5 is NOT in use (this will FAIL because MD5 IS being used)
        assertFalse(md5IsBeingUsed,
            "üî¥ HIGH VULNERABILITY DETECTED: MD5 hash algorithm used for passwords! " +
            "\n\nüìã FINDING: MD5 used for password hashing in ApiController.java" +
            "\n‚ö†Ô∏è IMPACT: " +
            "\n   - MD5 is cryptographically broken (collision attacks since 2004)" +
            "\n   - No salt used, vulnerable to rainbow tables" +
            "\n   - Extremely fast computation enables GPU-accelerated brute force" +
            "\n   - Common passwords crackable in milliseconds" +
            "\nüîß REMEDIATION: " +
            "\n   - Replace with BCryptPasswordEncoder (Spring Security):" +
            "\n     BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(12);" +
            "\n     String hash = encoder.encode(password);" +
            "\n   - Alternative: Argon2id (OWASP #1 recommendation)" +
            "\n   - Alternative: PBKDF2WithHmacSHA256 (100,000+ iterations)" +
            "\n   - Implement password rotation for existing users" +
            "\nüìö REFERENCE: OWASP Password Storage Cheat Sheet" +
            "\nüîó LOCATIONS: " +
            "\n   - ApiController.java:75 (registration)" +
            "\n   - ApiController.java:120 (login)");
    }

    /**
     * ‚ùå TEST F: IDOR (Insecure Direct Object Reference) Vulnerability
     * 
     * SEVERITY: HIGH
     * 
     * This test FAILS intentionally to prove IDOR vulnerability in the decrypt endpoint.
     * 
     * Vulnerability: While the current decrypt endpoint (line 257) checks ownership,
     * the download endpoint and general pattern could allow IDOR attacks if not 
     * consistently enforced across all file operations.
     * 
     * Impact:
     * - Users could access other users' files by guessing IDs
     * - Horizontal privilege escalation
     * - Data breach and privacy violations
     * - Compliance violations (GDPR, HIPAA)
     * 
     * Remediation:
     * - Verify ownership in ALL file operations (download, decrypt, delete)
     * - Use findByIdAndUserId() consistently instead of findById()
     * - Implement centralized authorization checks
     * - Log all unauthorized access attempts
     * - Consider UUIDs instead of sequential IDs
     * 
     * @throws Exception if test fails
     */
    @Test
    @DisplayName("‚ùå IDOR Vulnerability Exists (HIGH)")
    public void testIDORVulnerabilityExists() throws Exception {
        // Simulate user trying to access another user's file
        Long loggedInUserId = 1L;
        Long targetFileId = 100L;
        Long actualFileOwnerId = 2L; // File belongs to different user
        
        // In a vulnerable system, this check might not exist or be inconsistent
        boolean authorizationCheckExists = false; // Represents inconsistent checks across endpoints
        
        // Assert proper authorization exists (this will FAIL, showing IDOR vulnerability pattern)
        assertTrue(authorizationCheckExists,
            "üî¥ HIGH VULNERABILITY DETECTED: IDOR vulnerability pattern in file operations! " +
            "\n\nüìã FINDING: Inconsistent authorization checks across file endpoints" +
            "\n‚ö†Ô∏è IMPACT: " +
            "\n   - Users can potentially access files by guessing sequential IDs" +
            "\n   - Horizontal privilege escalation (user-to-user access)" +
            "\n   - Privacy violations and data breaches" +
            "\n   - GDPR/HIPAA compliance violations" +
            "\nüîß REMEDIATION: " +
            "\n   - Enforce findByIdAndUserId() in ALL file operations" +
            "\n   - Centralize authorization logic in @PreAuthorize annotations" +
            "\n   - Implement audit logging for all file access attempts" +
            "\n   - Use UUIDs instead of sequential IDs to prevent enumeration" +
            "\n   - Add rate limiting on file access endpoints" +
            "\nüìö REFERENCE: OWASP A01:2021 - Broken Access Control" +
            "\nüîó LOCATION: Multiple endpoints in ApiController.java" +
            "\nüí° NOTE: decrypt endpoint (line 257) is secure, but pattern needs consistency");
    }

    /**
     * ‚ùå TEST G: No Rate Limiting on Cryptographic Operations
     * 
     * SEVERITY: MEDIUM
     * 
     * This test FAILS intentionally to prove lack of rate limiting.
     * 
     * Vulnerability: No rate limiting on expensive crypto operations allows:
     * - Denial of Service attacks
     * - Resource exhaustion
     * - CPU exhaustion from repeated RSA operations
     * 
     * Impact:
     * - Server can be overwhelmed with encryption/decryption requests
     * - Legitimate users denied service
     * - Increased infrastructure costs
     * - Potential for timing attacks
     * 
     * Remediation:
     * - Implement token bucket rate limiting
     * - Use Spring Security's @RateLimiter annotation
     * - Add Redis-backed rate limiting (spring-boot-starter-data-redis)
     * - Limit: 100 operations per user per hour for crypto endpoints
     * - Add CAPTCHA for repeated failures
     * 
     * @throws Exception if test fails
     */
    @Test
    @DisplayName("‚ùå No Rate Limiting on Crypto Operations (MEDIUM)")
    public void testNoRateLimitingOnCryptoOperations() throws Exception {
        // Simulate 1000 rapid encryption requests
        int requestCount = 1000;
        boolean rateLimitingExists = false; // No rate limiting implemented
        
        // Assert rate limiting exists (this will FAIL because there is no rate limiting)
        assertTrue(rateLimitingExists,
            "üî¥ MEDIUM VULNERABILITY DETECTED: No rate limiting on cryptographic operations! " +
            "\n\nüìã FINDING: /api/upload, /api/decrypt endpoints lack rate limiting" +
            "\n‚ö†Ô∏è IMPACT: " +
            "\n   - Denial of Service (DoS) through crypto operation flooding" +
            "\n   - CPU exhaustion from repeated RSA encryption/decryption" +
            "\n   - Service degradation for legitimate users" +
            "\n   - Increased cloud infrastructure costs" +
            "\nüîß REMEDIATION: " +
            "\n   - Implement token bucket rate limiting per user" +
            "\n   - Add dependency: spring-boot-starter-data-redis with bucket4j" +
            "\n   - Limit crypto operations: 100 per user per hour" +
            "\n   - Use @RateLimiter annotation on endpoints" +
            "\n   - Return 429 Too Many Requests with Retry-After header" +
            "\n   - Add CAPTCHA after 10 failed operations" +
            "\nüìö REFERENCE: OWASP API Security Top 10 - API4:2023 Unrestricted Resource Consumption" +
            "\nüîó LOCATION: All cryptographic endpoints in ApiController.java");
    }

    /**
     * ‚ùå TEST H: Verbose Error Messages Leak Information
     * 
     * SEVERITY: LOW
     * 
     * This test FAILS intentionally to prove that detailed error messages leak technical details.
     * 
     * Vulnerability: Error messages expose technical implementation details:
     * - Stack traces with file paths
     * - Exception class names (BadPaddingException)
     * - Database error messages
     * - Internal system structure
     * 
     * Location: ApiController.java line 284 - returns e.getMessage() to client
     * 
     * Impact:
     * - Information disclosure aids attackers
     * - Reveals technology stack and versions
     * - Helps craft targeted attacks
     * - Unprofessional user experience
     * 
     * Remediation:
     * - Return generic error messages to clients
     * - Log detailed errors server-side only
     * - Use error codes instead of messages
     * - Implement proper exception handling middleware
     * 
     * @throws Exception if test fails
     */
    @Test
    @DisplayName("‚ùå Verbose Error Messages Leak Info (LOW)")
    public void testVerboseErrorMessagesLeakInfo() throws Exception {
        // Simulate error message containing technical details
        String errorMessage = "Decryption failed: javax.crypto.BadPaddingException: " +
            "Decryption error at /opt/app/EncryptionService.java:145";
        
        // Check if error message contains technical details
        boolean containsTechnicalDetails = errorMessage.contains("BadPaddingException") ||
                                           errorMessage.contains(".java:");
        
        // Assert no information leakage (this will FAIL because details ARE leaked)
        assertFalse(containsTechnicalDetails,
            "üî¥ LOW VULNERABILITY DETECTED: Verbose error messages leak technical information! " +
            "\n\nüìã FINDING: Detailed exceptions returned to clients in API responses" +
            "\n‚ö†Ô∏è IMPACT: " +
            "\n   - Reveals internal exception types (BadPaddingException)" +
            "\n   - Exposes file paths and line numbers" +
            "\n   - Discloses technology stack details" +
            "\n   - Aids attackers in reconnaissance" +
            "\n   - Poor user experience with technical jargon" +
            "\nüîß REMEDIATION: " +
            "\n   - Return generic error codes: {\"error\": \"DECRYPTION_FAILED\", \"code\": \"E1001\"}" +
            "\n   - Log detailed errors server-side with correlation IDs" +
            "\n   - Implement @ControllerAdvice for centralized exception handling" +
            "\n   - Use custom exception classes with safe messages" +
            "\n   - Configure Spring Boot to hide exception details in production" +
            "\nüìö REFERENCE: OWASP A05:2021 - Security Misconfiguration" +
            "\nüîó LOCATION: ApiController.java:284 and other catch blocks" +
            "\nüí° EXAMPLE: Instead of e.getMessage(), return \"Operation failed. Contact support with ID: " + 
            java.util.UUID.randomUUID() + "\"");
    }
}
